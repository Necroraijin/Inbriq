<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inbriq - 3D Network Visualization</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
            --dark-color: #34495e;
        }

        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 1000;
            min-width: 300px;
        }

        .control-panel h4 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--dark-color);
        }

        .control-group select,
        .control-group input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: var(--secondary-color);
        }

        .btn-3d {
            background: linear-gradient(135deg, var(--secondary-color), #5dade2);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn-3d:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 1000;
            min-width: 250px;
        }

        .info-panel h5 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-weight: 600;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-label {
            font-weight: 500;
            color: var(--dark-color);
        }

        .info-value {
            font-weight: 600;
            color: var(--secondary-color);
        }

        .threat-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(231, 76, 60, 0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            font-weight: 600;
            box-shadow: 0 5px 20px rgba(231, 76, 60, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--secondary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 1000;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .legend-text {
            font-size: 14px;
            color: var(--dark-color);
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Loading Overlay -->
        <div id="loading-overlay" class="loading-overlay">
            <div class="loading-spinner"></div>
        </div>

        <!-- 3D Canvas Container -->
        <div id="canvas-container"></div>

        <!-- Control Panel -->
        <div class="control-panel">
            <h4><i class="fas fa-cogs"></i> 3D Network Controls</h4>
            
            <div class="control-group">
                <label>Visualization Mode</label>
                <select id="visualization-mode">
                    <option value="network">Network Topology</option>
                    <option value="threats">Threat Landscape</option>
                    <option value="traffic">Traffic Flow</option>
                    <option value="trust">Trust Network</option>
                </select>
            </div>

            <div class="control-group">
                <label>Node Size</label>
                <input type="range" id="node-size" min="0.5" max="3" step="0.1" value="1">
            </div>

            <div class="control-group">
                <label>Connection Opacity</label>
                <input type="range" id="connection-opacity" min="0" max="1" step="0.1" value="0.6">
            </div>

            <div class="control-group">
                <label>Animation Speed</label>
                <input type="range" id="animation-speed" min="0" max="2" step="0.1" value="1">
            </div>

            <div class="control-group">
                <button class="btn-3d" onclick="toggleAnimation()">
                    <i class="fas fa-play"></i> Toggle Animation
                </button>
                <button class="btn-3d" onclick="resetCamera()">
                    <i class="fas fa-home"></i> Reset View
                </button>
            </div>

            <div class="control-group">
                <button class="btn-3d" onclick="simulateThreat()">
                    <i class="fas fa-exclamation-triangle"></i> Simulate Threat
                </button>
                <button class="btn-3d" onclick="highlightCritical()">
                    <i class="fas fa-star"></i> Highlight Critical
                </button>
            </div>
        </div>

        <!-- Info Panel -->
        <div class="info-panel">
            <h5><i class="fas fa-info-circle"></i> Network Status</h5>
            
            <div class="info-item">
                <span class="info-label">Total Nodes</span>
                <span class="info-value" id="total-nodes">0</span>
            </div>
            
            <div class="info-item">
                <span class="info-label">Active Connections</span>
                <span class="info-value" id="active-connections">0</span>
            </div>
            
            <div class="info-item">
                <span class="info-label">Threats Detected</span>
                <span class="info-value" id="threats-detected">0</span>
            </div>
            
            <div class="info-item">
                <span class="info-label">Trust Score</span>
                <span class="info-value" id="trust-score">0.0</span>
            </div>
            
            <div class="info-item">
                <span class="info-label">Network Health</span>
                <span class="info-value" id="network-health">Good</span>
            </div>
        </div>

        <!-- Threat Indicator -->
        <div id="threat-indicator" class="threat-indicator" style="display: none;">
            <i class="fas fa-exclamation-triangle"></i> THREAT DETECTED
        </div>

        <!-- Legend -->
        <div class="legend">
            <h6><i class="fas fa-list"></i> Legend</h6>
            
            <div class="legend-item">
                <div class="legend-color" style="background: #27ae60;"></div>
                <span class="legend-text">Secure Nodes</span>
            </div>
            
            <div class="legend-item">
                <div class="legend-color" style="background: #f39c12;"></div>
                <span class="legend-text">Suspicious Nodes</span>
            </div>
            
            <div class="legend-item">
                <div class="legend-color" style="background: #e74c3c;"></div>
                <span class="legend-text">Threat Nodes</span>
            </div>
            
            <div class="legend-item">
                <div class="legend-color" style="background: #3498db;"></div>
                <span class="legend-text">Normal Traffic</span>
            </div>
            
            <div class="legend-item">
                <div class="legend-color" style="background: #e74c3c;"></div>
                <span class="legend-text">Threat Traffic</span>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let nodes = [];
        let connections = [];
        let animationId;
        let isAnimating = true;
        let currentMode = 'network';

        // Network data
        let networkData = {
            nodes: [],
            connections: [],
            threats: [],
            traffic: []
        };

        // Initialize 3D scene
        function init3DScene() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 50);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Add renderer to container
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enablePan = true;

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Add fog for depth
            scene.fog = new THREE.Fog(0x0a0a0a, 10, 100);

            // Generate initial network
            generateNetworkData();
            createNetworkVisualization();

            // Start animation
            animate();

            // Hide loading overlay
            document.getElementById('loading-overlay').style.display = 'none';
        }

        // Generate network data
        function generateNetworkData() {
            networkData.nodes = [];
            networkData.connections = [];
            networkData.threats = [];
            networkData.traffic = [];

            // Generate nodes
            const nodeCount = 50;
            for (let i = 0; i < nodeCount; i++) {
                const node = {
                    id: `node_${i}`,
                    name: `Device ${i + 1}`,
                    type: Math.random() > 0.8 ? 'server' : 'client',
                    position: {
                        x: (Math.random() - 0.5) * 100,
                        y: (Math.random() - 0.5) * 100,
                        z: (Math.random() - 0.5) * 100
                    },
                    trustScore: Math.random(),
                    threatLevel: Math.random() > 0.9 ? 'high' : Math.random() > 0.7 ? 'medium' : 'low',
                    status: Math.random() > 0.1 ? 'active' : 'inactive'
                };
                networkData.nodes.push(node);
            }

            // Generate connections
            for (let i = 0; i < nodeCount; i++) {
                const connectionCount = Math.floor(Math.random() * 5) + 1;
                for (let j = 0; j < connectionCount; j++) {
                    const targetIndex = Math.floor(Math.random() * nodeCount);
                    if (targetIndex !== i) {
                        const connection = {
                            source: networkData.nodes[i].id,
                            target: networkData.nodes[targetIndex].id,
                            strength: Math.random(),
                            type: Math.random() > 0.1 ? 'normal' : 'suspicious',
                            traffic: Math.random() * 1000
                        };
                        networkData.connections.push(connection);
                    }
                }
            }

            // Generate threats
            for (let i = 0; i < 5; i++) {
                const threat = {
                    id: `threat_${i}`,
                    type: ['malware', 'ddos', 'intrusion', 'data_exfiltration'][Math.floor(Math.random() * 4)],
                    source: networkData.nodes[Math.floor(Math.random() * nodeCount)].id,
                    target: networkData.nodes[Math.floor(Math.random() * nodeCount)].id,
                    severity: ['low', 'medium', 'high', 'critical'][Math.floor(Math.random() * 4)],
                    timestamp: new Date()
                };
                networkData.threats.push(threat);
            }
        }

        // Create network visualization
        function createNetworkVisualization() {
            // Clear existing objects
            scene.clear();
            
            // Re-add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create nodes
            networkData.nodes.forEach(node => {
                const geometry = new THREE.SphereGeometry(1, 16, 16);
                let material;
                
                if (node.threatLevel === 'high') {
                    material = new THREE.MeshLambertMaterial({ color: 0xe74c3c });
                } else if (node.threatLevel === 'medium') {
                    material = new THREE.MeshLambertMaterial({ color: 0xf39c12 });
                } else {
                    material = new THREE.MeshLambertMaterial({ color: 0x27ae60 });
                }

                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(node.position.x, node.position.y, node.position.z);
                sphere.userData = node;
                sphere.castShadow = true;
                scene.add(sphere);
                nodes.push(sphere);
            });

            // Create connections
            networkData.connections.forEach(connection => {
                const sourceNode = networkData.nodes.find(n => n.id === connection.source);
                const targetNode = networkData.nodes.find(n => n.id === connection.target);
                
                if (sourceNode && targetNode) {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array([
                        sourceNode.position.x, sourceNode.position.y, sourceNode.position.z,
                        targetNode.position.x, targetNode.position.y, targetNode.position.z
                    ]);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                    let material;
                    if (connection.type === 'suspicious') {
                        material = new THREE.LineBasicMaterial({ 
                            color: 0xe74c3c, 
                            opacity: 0.6, 
                            transparent: true 
                        });
                    } else {
                        material = new THREE.LineBasicMaterial({ 
                            color: 0x3498db, 
                            opacity: 0.6, 
                            transparent: true 
                        });
                    }

                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    connections.push(line);
                }
            });

            updateInfoPanel();
        }

        // Animation loop
        function animate() {
            animationId = requestAnimationFrame(animate);

            if (isAnimating) {
                // Rotate nodes
                nodes.forEach((node, index) => {
                    node.rotation.x += 0.01;
                    node.rotation.y += 0.01;
                    
                    // Pulsing effect for threat nodes
                    if (node.userData.threatLevel === 'high') {
                        const scale = 1 + Math.sin(Date.now() * 0.005 + index) * 0.2;
                        node.scale.setScalar(scale);
                    }
                });

                // Animate connections
                connections.forEach((connection, index) => {
                    if (connection.material.opacity < 0.3) {
                        connection.material.opacity = 0.6;
                    } else {
                        connection.material.opacity -= 0.01;
                    }
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Control functions
        function toggleAnimation() {
            isAnimating = !isAnimating;
        }

        function resetCamera() {
            camera.position.set(0, 0, 50);
            controls.reset();
        }

        function simulateThreat() {
            // Add a new threat
            const threatNode = nodes[Math.floor(Math.random() * nodes.length)];
            threatNode.userData.threatLevel = 'high';
            threatNode.material.color.setHex(0xe74c3c);
            
            // Show threat indicator
            document.getElementById('threat-indicator').style.display = 'block';
            setTimeout(() => {
                document.getElementById('threat-indicator').style.display = 'none';
            }, 3000);
            
            updateInfoPanel();
        }

        function highlightCritical() {
            nodes.forEach(node => {
                if (node.userData.threatLevel === 'high') {
                    node.material.emissive.setHex(0xff0000);
                    node.material.emissiveIntensity = 0.3;
                }
            });
        }

        // Update info panel
        function updateInfoPanel() {
            document.getElementById('total-nodes').textContent = nodes.length;
            document.getElementById('active-connections').textContent = connections.length;
            document.getElementById('threats-detected').textContent = 
                nodes.filter(n => n.userData.threatLevel === 'high').length;
            
            const avgTrustScore = nodes.reduce((sum, node) => sum + node.userData.trustScore, 0) / nodes.length;
            document.getElementById('trust-score').textContent = avgTrustScore.toFixed(2);
            
            const threatCount = nodes.filter(n => n.userData.threatLevel === 'high').length;
            const health = threatCount > 5 ? 'Critical' : threatCount > 2 ? 'Warning' : 'Good';
            document.getElementById('network-health').textContent = health;
        }

        // Event listeners
        document.getElementById('visualization-mode').addEventListener('change', (e) => {
            currentMode = e.target.value;
            createNetworkVisualization();
        });

        document.getElementById('node-size').addEventListener('input', (e) => {
            const scale = parseFloat(e.target.value);
            nodes.forEach(node => {
                node.scale.setScalar(scale);
            });
        });

        document.getElementById('connection-opacity').addEventListener('input', (e) => {
            const opacity = parseFloat(e.target.value);
            connections.forEach(connection => {
                connection.material.opacity = opacity;
            });
        });

        document.getElementById('animation-speed').addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            // Adjust animation speed based on input
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize when page loads
        window.addEventListener('load', () => {
            init3DScene();
        });

        // Add click interaction
        document.addEventListener('click', (event) => {
            if (event.target.tagName === 'CANVAS') {
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(nodes);
                if (intersects.length > 0) {
                    const node = intersects[0].object;
                    console.log('Clicked node:', node.userData);
                    
                    // Highlight clicked node
                    node.material.emissive.setHex(0x00ff00);
                    node.material.emissiveIntensity = 0.5;
                    
                    setTimeout(() => {
                        node.material.emissive.setHex(0x000000);
                        node.material.emissiveIntensity = 0;
                    }, 1000);
                }
            }
        });
    </script>
</body>
</html>
